/// DAX Assertion Library Functions
/// Publisher: PQL (Power Query Lint)
/// These functions provide a standardized way to write unit tests for DAX models
/// Basic Assertions - PQL.Assert namespace
function 'PQL.Assert.ShouldBeTrue' =
        (testName : STRING, actualCondition : BOOLEAN) =>
            VAR _Passed = actualCondition = TRUE
            RETURN ROW(
                "TestName", testName,
                "Expected", "TRUE",
                "Actual", IF(actualCondition, "TRUE", "FALSE"),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10

function 'PQL.Assert.ShouldBeFalse' =
        (testName : STRING, actualCondition : BOOLEAN) =>
            VAR _Passed = actualCondition = FALSE
            RETURN ROW(
                "TestName", testName,
                "Expected", "FALSE",
                "Actual", IF(actualCondition, "TRUE", "FALSE"),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a value is NULL (DAX BLANK()).
function 'PQL.Assert.ShouldBeNull' =
        (testName : STRING, actualValue : VARIANT) =>
            VAR _Passed = ISBLANK(actualValue)
            RETURN ROW(
                "TestName", testName,
                "Expected", "NULL",
                "Actual", IF(ISBLANK(actualValue), "NULL", IF(actualValue = "", "BLANK (empty string)", "HAS VALUE")),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a value is not NULL (not DAX BLANK()). Accepts both simple values and expressions.
function 'PQL.Assert.ShouldNotBeNull' =
        (testName : STRING, actualValue : SCALAR VARIANT EXPR) =>
            VAR _ActualResult = actualValue
            VAR _Passed = NOT ISBLANK(_ActualResult)
            RETURN ROW(
                "TestName", testName,
                "Expected", "NOT NULL",
                "Actual", IF(ISBLANK(_ActualResult), "NULL", IF(_ActualResult = "", "BLANK (empty string)", "HAS VALUE")),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a value is BLANK (empty string "").
function 'PQL.Assert.ShouldBeBlank' =
        (testName : STRING, actualValue : VARIANT) =>
            VAR _Passed = NOT ISBLANK(actualValue) && actualValue = ""
            RETURN ROW(
                "TestName", testName,
                "Expected", "BLANK (empty string)",
                "Actual", IF(ISBLANK(actualValue), "NULL", IF(actualValue = "", "BLANK (empty string)", "HAS VALUE")),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a value is not BLANK (not empty string "").
function 'PQL.Assert.ShouldNotBeBlank' =
        (testName : STRING, actualValue : SCALAR VARIANT EXPR) =>
            VAR _ActualResult = actualValue
            VAR _Passed = ISBLANK(_ActualResult) || _ActualResult <> ""
            RETURN ROW(
                "TestName", testName,
                "Expected", "NOT BLANK (not empty string)",
                "Actual", IF(ISBLANK(_ActualResult), "NULL", IF(_ActualResult = "", "BLANK (empty string)", "HAS VALUE")),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a value is NULL or BLANK (BLANK() or empty string "").
function 'PQL.Assert.ShouldBeNullOrBlank' =
        (testName : STRING, actualValue : VARIANT) =>
            VAR _Passed = ISBLANK(actualValue) || actualValue = ""
            RETURN ROW(
                "TestName", testName,
                "Expected", "NULL OR BLANK",
                "Actual", IF(ISBLANK(actualValue), "NULL", IF(actualValue = "", "BLANK (empty string)", "HAS VALUE")),
                "Passed", _Passed
            )

    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a value is not NULL and not BLANK (has actual content).
function 'PQL.Assert.ShouldNotBeNullOrBlank' =
        (testName : STRING, actualValue : SCALAR VARIANT EXPR) =>
            VAR _ActualResult = actualValue
            VAR _Passed = NOT ISBLANK(_ActualResult) && _ActualResult <> ""
            RETURN ROW(
                "TestName", testName,
                "Expected", "NOT NULL AND NOT BLANK",
                "Actual", IF(ISBLANK(_ActualResult), "NULL", IF(_ActualResult = "", "BLANK (empty string)", "HAS VALUE")),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10

function 'PQL.Assert.ShouldEqual' =
        (testName : STRING, expected : VARIANT, actual : VARIANT) =>
            VAR _Passed = expected = actual
            RETURN ROW(
                "TestName", testName,
                "Expected", FORMAT(expected, ""),
                "Actual", FORMAT(actual, ""),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10

function 'PQL.Assert.ShouldNotEqual' =
        (testName : STRING, notExpected : VARIANT, actual : VARIANT) =>
            VAR _Passed = notExpected <> actual
            RETURN ROW(
                "TestName", testName,
                "Expected", "NOT " & FORMAT(notExpected, ""),
                "Actual", FORMAT(actual, ""),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that two strings are exactly equal (case-sensitive comparison).
function 'PQL.Assert.ShouldEqualExactly' =
        (testName : STRING, expected : STRING, actual : STRING) =>
            VAR _Passed = EXACT(expected, actual)
            RETURN ROW(
                "TestName", testName,
                "Expected", expected,
                "Actual", actual,
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10

function 'PQL.Assert.ShouldBeGreaterThan' =
        (testName : STRING, threshold : DOUBLE, actual : DOUBLE) =>
            VAR _Passed = actual > threshold
            RETURN ROW(
                "TestName", testName,
                "Expected", "> " & FORMAT(threshold, ""),
                "Actual", FORMAT(actual, ""),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10

function 'PQL.Assert.ShouldBeLessThan' =
        (testName : STRING, threshold : DOUBLE, actual : DOUBLE) =>
            VAR _Passed = actual < threshold
            RETURN ROW(
                "TestName", testName,
                "Expected", "< " & FORMAT(threshold, ""),
                "Actual", FORMAT(actual, ""),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a number is greater than or equal to an expected value.
function 'PQL.Assert.ShouldBeGreaterOrEqual' =
        (testName : STRING, threshold : DOUBLE, actual : DOUBLE) =>
            VAR _Passed = actual >= threshold
            RETURN ROW(
                "TestName", testName,
                "Expected", ">= " & FORMAT(threshold, ""),
                "Actual", FORMAT(actual, ""),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a number is less than or equal to an expected value.
function 'PQL.Assert.ShouldBeLessOrEqual' =
        (testName : STRING, threshold : DOUBLE, actual : DOUBLE) =>
            VAR _Passed = actual <= threshold
            RETURN ROW(
                "TestName", testName,
                "Expected", "<= " & FORMAT(threshold, ""),
                "Actual", FORMAT(actual, ""),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10

function 'PQL.Assert.ShouldBeBetween' =
        (testName : STRING, lowerBound : DOUBLE, upperBound : DOUBLE, actual : DOUBLE) =>
            VAR _Passed = actual >= lowerBound && actual <= upperBound
            RETURN ROW(
                "TestName", testName,
                "Expected", FORMAT(lowerBound, "") & " <= value <= " & FORMAT(upperBound, ""),
                "Actual", FORMAT(actual, ""),
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// String Assertions - PQL.Assert namespace
/// Asserts that a string starts with the specified prefix (case-insensitive).
function 'PQL.Assert.ShouldStartWith' =
        (testName : STRING, prefix : STRING, actual : STRING) =>
            VAR _Passed = LEFT(UPPER(actual), LEN(prefix)) = UPPER(prefix)
            RETURN ROW(
                "TestName", testName,
                "Expected", "Starts with '" & prefix & "'",
                "Actual", actual,
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a string ends with the specified suffix (case-insensitive).
function 'PQL.Assert.ShouldEndWith' =
        (testName : STRING, suffix : STRING, actual : STRING) =>
            VAR _Passed = RIGHT(UPPER(actual), LEN(suffix)) = UPPER(suffix)
            RETURN ROW(
                "TestName", testName,
                "Expected", "Ends with '" & suffix & "'",
                "Actual", actual,
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a string contains the specified substring (case-insensitive).
function 'PQL.Assert.ShouldContainString' =
        (testName : STRING, substring : STRING, actual : STRING) =>
            VAR _Passed = CONTAINSSTRING(actual, substring)
            RETURN ROW(
                "TestName", testName,
                "Expected", "Contains '" & substring & "'",
                "Actual", actual,
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a string matches a pattern (case-insensitive).
function 'PQL.Assert.ShouldMatch' =
        (testName : STRING, pattern : STRING, actual : STRING) =>
            VAR _Passed = CONTAINSSTRING(actual, pattern)
            RETURN ROW(
                "TestName", testName,
                "Expected", "Matches '" & pattern & "'",
                "Actual", actual,
                "Passed", _Passed
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Relationship Assertions - PQL.Assert.Relationship namespace
function 'PQL.Assert.Relationship.ShouldExist' =
        (testName : STRING, fromTable : STRING, fromColumn : STRING, toTable : STRING, toColumn : STRING) =>
            VAR _Relationships = INFO.VIEW.RELATIONSHIPS()
            VAR _Found = COUNTROWS(FILTER(_Relationships,
                [FromTable] = fromTable && [FromColumn] = fromColumn &&
                [ToTable] = toTable && [ToColumn] = toColumn)) > 0
            RETURN ROW(
                "TestName", testName,
                "Expected", "Relationship '" & fromTable & "[" & fromColumn & "] -> " & toTable & "[" & toColumn & "]' exists",
                "Actual", IF(_Found, "EXISTS", "NOT FOUND"),
                "Passed", _Found
            )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Test Discovery Functions - PQL.Assert namespace
function 'PQL.Assert.RetrieveTests' =
        () =>
            FILTER(INFO.FUNCTIONS("ORIGIN", "2"), OR(RIGHT([FUNCTION_NAME],5) = ".Test", RIGHT([FUNCTION_NAME],6) = ".Tests"))
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10`n/// Retrieves tests filtered by environment. Looks for .{ENV}. or .ANY. in function names.
/// If environment is blank, returns all tests.
/// Supports any custom environment naming convention (DEV, TEST, PROD, UAT, STAGING, etc.)
function 'PQL.Assert.RetrieveTestsByEnvironment' =
        (environment: STRING) =>
            VAR _EnvUpper = UPPER(environment)
            RETURN
                FILTER(
                    INFO.FUNCTIONS("ORIGIN", "2"),
                    (RIGHT([FUNCTION_NAME], 5) = ".Test" || RIGHT([FUNCTION_NAME], 6) = ".Tests")
                    && (
                        ISBLANK(_EnvUpper) || _EnvUpper = ""
                        || CONTAINSSTRING(UPPER([FUNCTION_NAME]), "." & _EnvUpper & ".")
                        || CONTAINSSTRING(UPPER([FUNCTION_NAME]), ".ANY.")
                    )
                )
    annotation DAXLIB_PackageId = PQL.Assert
    annotation DAXLIB_PackageVersion = 0.1.10
/// DAX Expression Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against DAX expression best practices
/// Asserts that column references in DAX expressions should be fully qualified.
/// Using fully qualified column references (Table[Column]) makes it easier to distinguish between columns and measures, and helps avoid certain errors.
function 'PQL.Assert.BP.ShouldUseFullyQualifiedColumnReferences' =
		() =>
		    VAR _Measures = INFO.VIEW.MEASURES()
		    VAR _ViolatingMeasures =
		        FILTER(
		            _Measures,
		            VAR _Expression = [Expression]
		            VAR _HasUnqualifiedColumnRef =
		                // Check for unqualified column references in the expression
		                // This is a simplified check - looks for [ColumnName] not preceded by a table name
		                // Pattern: spaces or operators followed by [ but not preceded by alphanumeric/underscore
		                NOT ISBLANK(_Expression)
		                && (
		                    CONTAINSSTRING(_Expression, " [")
		                    || CONTAINSSTRING(_Expression, "([")
		                    || CONTAINSSTRING(_Expression, ",[")
		                    || LEFT(_Expression, 1) = "["
		                )
		                && NOT CONTAINSSTRING(_Expression, "'[") // Exclude table names with brackets
		            RETURN _HasUnqualifiedColumnRef
		        )
		    VAR _ViolatingMeasureCount = COUNTROWS(_ViolatingMeasures)
		    VAR _MeasuresList =
		        CONCATENATEX(
		            _ViolatingMeasures,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _ViolatingMeasureCount = 0
		    VAR _ActualMessage =
		        IF(
		            _ViolatingMeasureCount > 0,
		            "MEASURES WITH UNQUALIFIED COLUMN REFERENCES FOUND (" & FORMAT(_ViolatingMeasureCount, "0") & "): " & _MeasuresList,
		            "ALL COLUMN REFERENCES ARE FULLY QUALIFIED"
		        )
		    RETURN ROW(
		        "TestName", "[DAX Expressions] Column references should be fully qualified",
		        "Expected", "All column references should be fully qualified (Table[Column])",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Using fully qualified column references makes it easier to distinguish between column and measure references, and also helps avoid certain errors. Reference: https://www.elegantbi.com/post/top10bestpractices. Severity: Medium (2)."
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that measures should use TREATAS instead of INTERSECT for virtual relationships.
/// The TREATAS function is more efficient and provides better performance than the INTERSECT function when used in virtual relationships.
function 'PQL.Assert.BP.ShouldUseTreatAsInsteadOfIntersect' =
		() =>
		    VAR _Measures = INFO.VIEW.MEASURES()
		    VAR _ViolatingMeasures =
		        FILTER(
		            _Measures,
		            VAR _Expression = [Expression]
		            VAR _HasIntersect =
		                // Check for INTERSECT function usage (case-insensitive)
		                NOT ISBLANK(_Expression)
		                && (
		                    CONTAINSSTRING(UPPER(_Expression), "INTERSECT(")
		                    || CONTAINSSTRING(UPPER(_Expression), "INTERSECT (")
		                )
		            RETURN _HasIntersect
		        )
		    VAR _ViolatingMeasureCount = COUNTROWS(_ViolatingMeasures)
		    VAR _MeasuresList =
		        CONCATENATEX(
		            _ViolatingMeasures,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _ViolatingMeasureCount = 0
		    VAR _ActualMessage =
		        IF(
		            _ViolatingMeasureCount > 0,
		            "MEASURES USING INTERSECT FOUND (" & FORMAT(_ViolatingMeasureCount, "0") & "): " & _MeasuresList,
		            "NO MEASURES USE INTERSECT"
		        )
		    RETURN ROW(
		        "TestName", "[DAX Expressions] Use the TREATAS function instead of INTERSECT",
		        "Expected", "Measures should use TREATAS instead of INTERSECT for virtual relationships",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "The TREATAS function is more efficient and provides better performance than the INTERSECT function when used in virtual relationships. Reference: https://www.sqlbi.com/articles/propagate-filters-using-treatas-in-dax/. Severity: Medium (2)."
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Runs all DAX expression best practice checks.
/// This function executes all DAX expression validation rules and returns combined results.
function 'PQL.Assert.BP.CheckDAXExpressions' =
		() =>
		    UNION(
		        PQL.Assert.BP.ShouldUseFullyQualifiedColumnReferences(),
		        PQL.Assert.BP.ShouldUseTreatAsInsteadOfIntersect()
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10
/// Error Prevention Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against error prevention best practices
/// Asserts that relationship columns should be of the same data type.
/// Columns used in a relationship should be of the same data type. Having columns within a relationship which are of different data types may lead to various issues.
function 'PQL.Assert.BP.ShouldHaveSameDataTypeInRelationships' =
		() =>
		    VAR _Relationships = INFO.VIEW.RELATIONSHIPS()
		    VAR _Columns = INFO.VIEW.COLUMNS()

		    // Create a lookup for column data types
		    VAR _ColumnDataTypes =
		        SUMMARIZE(
		            _Columns,
		            [Table],
		            [Name],
		            [DataType]
		        )

		    // Check each relationship for data type mismatches
		    VAR _ViolatingRelationships =
		        FILTER(
		            _Relationships,
		            VAR _FromTable = [FromTable]
		            VAR _FromColumn = [FromColumn]
		            VAR _ToTable = [ToTable]
		            VAR _ToColumn = [ToColumn]

		            // Get data type of FromColumn
		            VAR _FromDataType =
		                MAXX(
		                    FILTER(
		                        _ColumnDataTypes,
		                        [Table] = _FromTable && [Name] = _FromColumn
		                    ),
		                    [DataType]
		                )

		            // Get data type of ToColumn
		            VAR _ToDataType =
		                MAXX(
		                    FILTER(
		                        _ColumnDataTypes,
		                        [Table] = _ToTable && [Name] = _ToColumn
		                    ),
		                    [DataType]
		                )

		            // Check if data types are different
		            RETURN
		                NOT ISBLANK(_FromDataType)
		                && NOT ISBLANK(_ToDataType)
		                && _FromDataType <> _ToDataType
		        )

		    VAR _ViolationCount = COUNTROWS(_ViolatingRelationships)

		    VAR _RelationshipsList =
		        CONCATENATEX(
		            _ViolatingRelationships,
		            [FromTable] & "[" & [FromColumn] & "] -> " & [ToTable] & "[" & [ToColumn] & "]",
		            ", ",
		            [FromTable], ASC,
		            [FromColumn], ASC
		        )

		    VAR _Passed = _ViolationCount = 0

		    VAR _ActualMessage =
		        IF(
		            _ViolationCount > 0,
		            "RELATIONSHIPS WITH MISMATCHED DATA TYPES FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _RelationshipsList,
		            "ALL RELATIONSHIP COLUMNS HAVE MATCHING DATA TYPES"
		        )

		    RETURN ROW(
		        "TestName", "[Error Prevention] Relationship columns should be of the same data type",
		        "Expected", "All relationship columns should have matching data types",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Columns used in a relationship should be of the same data type. Ideally, they will be of integer data type. Having columns within a relationship which are of different data types may lead to various issues including slower performance and unexpected query results. Severity: High (3)."
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Runs all error prevention best practice checks.
/// This function executes all error prevention validation rules and returns combined results.
function 'PQL.Assert.BP.CheckErrorPrevention' =
		() =>
		    PQL.Assert.BP.ShouldHaveSameDataTypeInRelationships()
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10
/// Formatting Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against formatting best practices
/// Asserts that visible measures should have their format string property assigned.
/// Measures without format strings may display inconsistently and make reports harder to understand.
function 'PQL.Assert.BP.ShouldProvideFormatStringForMeasures' =
		() =>
		    VAR _ViewMeasures = INFO.VIEW.MEASURES()
		    VAR _Measures = INFO.MEASURES()
		    VAR _Tables = INFO.VIEW.TABLES()

		    // Create a lookup for hidden tables
		    VAR _HiddenTables =
		        FILTER(
		            _Tables,
		            [IsHidden] = TRUE
		        )

		    // Check measures for missing format strings
		    VAR _ViolatingMeasures =
		        FILTER(
		            _ViewMeasures,
		            VAR _TableName = [Table]
		            VAR _MeasureID = [ID]

		            // Get FormatString from INFO.MEASURES()
		            VAR _FormatString =
		                MAXX(
		                    FILTER(
		                        _Measures,
		                        [ID] = _MeasureID
		                    ),
		                    [FormatString]
		                )

		            // Check if table is hidden
		            VAR _TableIsHidden =
		                COUNTROWS(
		                    FILTER(
		                        _HiddenTables,
		                        [Name] = _TableName
		                    )
		                ) > 0

		            // Measure is on a visible table and has no format string
		            RETURN
		                NOT _TableIsHidden
		                && (ISBLANK(_FormatString) || _FormatString = "")
		        )

		    VAR _ViolationCount = COUNTROWS(_ViolatingMeasures)

		    VAR _MeasuresList =
		        CONCATENATEX(
		            _ViolatingMeasures,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )

		    VAR _Passed = _ViolationCount = 0

		    VAR _ActualMessage =
		        IF(
		            _ViolationCount > 0,
		            "MEASURES WITHOUT FORMAT STRING FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _MeasuresList,
		            "ALL VISIBLE MEASURES HAVE FORMAT STRINGS ASSIGNED"
		        )

		    RETURN ROW(
		        "TestName", "[Formatting] Provide format string for measures",
		        "Expected", "All visible measures should have format strings assigned",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Visible measures should have their format string property assigned. Measures without format strings may display inconsistently and make reports harder to understand. Severity: High (3)."
		    )
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that numeric columns should have SummarizeBy set to None.
/// Numeric columns with SummarizeBy enabled may cause accidental aggregation in reports. Users should create explicit measures instead.
function 'PQL.Assert.BP.ShouldNotSummarizeNumericColumns' =
		() =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _Tables = INFO.VIEW.TABLES()

		    // Create a lookup for hidden tables
		    VAR _HiddenTables =
		        FILTER(
		            _Tables,
		            [IsHidden] = TRUE
		        )

		    // Check numeric columns with SummarizeBy not set to None
		    VAR _ViolatingColumns =
		        FILTER(
		            _Columns,
		            VAR _TableName = [Table]
		            VAR _DataType = [DataType]
		            VAR _IsHidden = [IsHidden]
		            VAR _SummarizeBy = [SummarizeBy]

		            // Check if table is hidden
		            VAR _TableIsHidden =
		                COUNTROWS(
		                    FILTER(
		                        _HiddenTables,
		                        [Name] = _TableName
		                    )
		                ) > 0

		            // Column is numeric (Int64, Decimal, or Double)
		            VAR _IsNumeric =
		                _DataType = "Integer"
		                || _DataType = "Currency"
		                || _DataType = "Number"

		            // Check if SummarizeBy is not set to None
		            RETURN
		                _IsNumeric
		                && NOT _IsHidden
		                && NOT _TableIsHidden
		                && _SummarizeBy <> "None"
		        )

		    VAR _ViolationCount = COUNTROWS(_ViolatingColumns)

		    VAR _ColumnsList =
		        CONCATENATEX(
		            _ViolatingColumns,
		            [Table] & "[" & [Name] & "] (SummarizeBy: " & [SummarizeBy] & ")",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )

		    VAR _Passed = _ViolationCount = 0

		    VAR _ActualMessage =
		        IF(
		            _ViolationCount > 0,
		            "NUMERIC COLUMNS WITH SUMMARIZE BY FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _ColumnsList,
		            "ALL NUMERIC COLUMNS HAVE SUMMARIZE BY SET TO NONE"
		        )

		    RETURN ROW(
		        "TestName", "[Formatting] Do not summarize numeric columns",
		        "Expected", "Numeric columns should have SummarizeBy set to None",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Numeric columns (Int64, Decimal, Double) should have their SummarizeBy property set to None to avoid accidental aggregation in Power BI. Users should create explicit measures instead. Severity: High (3)."
		    )
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that tables should have at least one column marked as a row label (IsDefaultLabel = true).
/// Row labels help Power BI Copilot understand which columns represent the primary identifier for rows in a table.
/// Reference: https://blog.crossjoin.co.uk/2024/08/25/tuning-power-bi-copilot-with-row-labels-and-key-columns/
function 'PQL.Assert.BP.ShouldMarkRowLabels' =
		() =>
		    VAR _Columns = INFO.COLUMNS()
		    VAR _Tables = INFO.TABLES()

		    // Get visible tables (excluding hidden and system tables)
		    VAR _VisibleTables =
		        FILTER(
		            _Tables,
		            NOT [IsHidden]
		            && NOT CONTAINSSTRING([Name], "DateTableTemplate")
		            && NOT CONTAINSSTRING([Name], "LocalDateTable")
		        )

		    // Check each visible table for row labels
		    VAR _TablesWithoutRowLabels =
		        ADDCOLUMNS(
		            _VisibleTables,
		            "@HasRowLabel",
		                VAR _TableID = [ID]
		                VAR _RowLabelCount =
		                    COUNTROWS(
		                        FILTER(
		                            _Columns,
		                            [TableID] = _TableID
		                            && [IsDefaultLabel] = TRUE
		                            && NOT [IsHidden]
		                        )
		                    )
		                RETURN _RowLabelCount > 0
		        )

		    VAR _ViolatingTables =
		        FILTER(
		            _TablesWithoutRowLabels,
		            [@HasRowLabel] = FALSE
		        )

		    VAR _ViolationCount = COUNTROWS(_ViolatingTables)

		    VAR _TablesList =
		        CONCATENATEX(
		            _ViolatingTables,
		            [Name],
		            ", ",
		            [Name], ASC
		        )

		    VAR _Passed = _ViolationCount = 0

		    VAR _ActualMessage =
		        IF(
		            _ViolationCount > 0,
		            "TABLES WITHOUT ROW LABELS FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _TablesList,
		            "ALL TABLES HAVE ROW LABELS ASSIGNED"
		        )

		    RETURN ROW(
		        "TestName", "[Formatting] Mark row labels",
		        "Expected", "Tables should have at least one column marked as a row label",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Set the 'RowLabel' property to 'True' for row label columns within the column properties. This helps Power BI Copilot understand which columns represent the primary identifier for rows in a table. Reference: https://blog.crossjoin.co.uk/2024/08/25/tuning-power-bi-copilot-with-row-labels-and-key-columns/. Severity: High (3)."
		    )
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that columns on the "One" side of relationships should have the IsKey property set to true.
/// Marking primary keys helps Power BI understand table relationships and optimize query performance.
function 'PQL.Assert.BP.ShouldMarkPrimaryKeys' =
		() =>
		    VAR _Columns = INFO.COLUMNS()
		    VAR _Tables = INFO.TABLES()
		    VAR _Relationships = INFO.RELATIONSHIPS()

		    // Get columns that are on the "One" side of relationships (primary keys)
		    // ToCardinality is Int64: 1 = One, 2 = Many
		    VAR _PrimaryKeyColumns =
		        ADDCOLUMNS(
		            FILTER(
		                _Relationships,
		                [ToCardinality] = 1
		            ),
		            "@ToTableID", [ToTableID],
		            "@ToColumnID", [ToColumnID]
		        )

		    // Find columns that should be marked as keys but aren't
		    VAR _ViolatingColumns =
		        FILTER(
		            _Columns,
		            VAR _ColumnID = [ID]
		            VAR _TableID = [TableID]
		            VAR _IsHidden = [IsHidden]
		            VAR _IsKey = [IsKey]

		            // Get table information
		            VAR _TableIsHidden =
		                COUNTROWS(
		                    FILTER(
		                        _Tables,
		                        [ID] = _TableID
		                        && [IsHidden] = TRUE
		                    )
		                ) > 0

		            VAR _TableDataCategory =
		                MAXX(
		                    FILTER(
		                        _Tables,
		                        [ID] = _TableID
		                    ),
		                    [DataCategory]
		                )

		            // Check if this column is a primary key in any relationship
		            VAR _IsPrimaryKey =
		                COUNTROWS(
		                    FILTER(
		                        _PrimaryKeyColumns,
		                        [@ToColumnID] = _ColumnID
		                    )
		                ) > 0

		            // Return true if column should be marked as key but isn't
		            RETURN
		                _IsPrimaryKey
		                && NOT _IsKey
		                && NOT _IsHidden
		                && NOT _TableIsHidden
		                && (_TableDataCategory <> "Time" || ISBLANK(_TableDataCategory))
		        )

		    VAR _ViolationCount = COUNTROWS(_ViolatingColumns)

		    // Build detailed list with table and column names
		    VAR _ColumnsList =
		        CONCATENATEX(
		            _ViolatingColumns,
		            VAR _TableID = [TableID]
		            VAR _TableName =
		                MAXX(
		                    FILTER(
		                        _Tables,
		                        [ID] = _TableID
		                    ),
		                    [Name]
		                )
		            RETURN _TableName & "[" & [ExplicitName] & "]",
		            ", "
		        )

		    VAR _Passed = _ViolationCount = 0

		    VAR _ActualMessage =
		        IF(
		            _ViolationCount > 0,
		            "PRIMARY KEY COLUMNS NOT MARKED AS KEYS FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _ColumnsList,
		            "ALL PRIMARY KEY COLUMNS ARE MARKED AS KEYS"
		        )

		    RETURN ROW(
		        "TestName", "[Formatting] Mark primary keys",
		        "Expected", "Columns on the 'One' side of relationships should have IsKey = true",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Set the 'Key' property to 'True' for primary key columns within the column properties. This helps Power BI understand table relationships and optimize query performance. Severity: High (3)."
		    )
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that visible numeric columns used in aggregation measures should be hidden.
/// It is a best practice to hide fact table columns that are used for aggregation in measures.
/// Reference: https://blog.crossjoin.co.uk/2024/06/09/get-better-results-from-power-bi-copilot-with-linguistic-modelling/
function 'PQL.Assert.BP.ShouldHideFactTableColumns' =
		() =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _Tables = INFO.VIEW.TABLES()
		    VAR _Measures = INFO.MEASURES()
		    VAR _AllTables = INFO.TABLES()

		    // Get hidden tables for filtering
		    VAR _HiddenTables =
		        FILTER(
		            _Tables,
		            [IsHidden] = TRUE
		        )

		    // Get visible numeric columns on visible tables
		    VAR _NumericColumns =
		        FILTER(
		            _Columns,
		            VAR _TableName = [Table]
		            VAR _DataType = [DataType]
		            VAR _IsHidden = [IsHidden]

		            // Check if table is hidden
		            VAR _TableIsHidden =
		                COUNTROWS(
		                    FILTER(
		                        _HiddenTables,
		                        [Name] = _TableName
		                    )
		                ) > 0

		            RETURN
		                NOT _IsHidden
		                && NOT _TableIsHidden
		                && (_DataType = "Integer" || _DataType = "Currency" || _DataType = "Number")
		        )

		    // For each visible numeric column, check if any measure references it in an aggregation function
		    VAR _ViolatingColumns =
		        FILTER(
		            _NumericColumns,
		            VAR _ColName = [Name]
		            VAR _TableName = [Table]

		            // Build column reference patterns
		            VAR _QualifiedRef = "'" & _TableName & "'[" & _ColName & "]"
		            VAR _UnqualifiedRef = _TableName & "[" & _ColName & "]"
		            VAR _ShortRef = "[" & _ColName & "]"

		            // Check if any measure uses this column in an aggregation function
		            VAR _IsAggregated =
		                COUNTROWS(
		                    FILTER(
		                        _Measures,
		                        VAR _Expr = UPPER([Expression])
		                        VAR _MeasureTableName =
		                            MAXX(
		                                FILTER(_AllTables, [ID] = EARLIER([TableID])),
		                                [Name]
		                            )
		                        RETURN
		                            CONTAINSSTRING(_Expr, UPPER("SUM(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("SUM(" & _UnqualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("COUNT(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("COUNT(" & _UnqualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("COUNTBLANK(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("COUNTBLANK(" & _UnqualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("AVERAGE(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("AVERAGE(" & _UnqualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("DISTINCTCOUNT(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("DISTINCTCOUNT(" & _UnqualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("MIN(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("MIN(" & _UnqualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("MAX(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("MAX(" & _UnqualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("COUNTA(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("COUNTA(" & _UnqualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("AVERAGEA(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("AVERAGEA(" & _UnqualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("MAXA(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("MAXA(" & _UnqualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("MINA(" & _QualifiedRef))
		                            || CONTAINSSTRING(_Expr, UPPER("MINA(" & _UnqualifiedRef))
		                            // Same-table unqualified short reference
		                            || (_MeasureTableName = _TableName && (
		                                CONTAINSSTRING(_Expr, UPPER("SUM(" & _ShortRef))
		                                || CONTAINSSTRING(_Expr, UPPER("COUNT(" & _ShortRef))
		                                || CONTAINSSTRING(_Expr, UPPER("COUNTBLANK(" & _ShortRef))
		                                || CONTAINSSTRING(_Expr, UPPER("AVERAGE(" & _ShortRef))
		                                || CONTAINSSTRING(_Expr, UPPER("DISTINCTCOUNT(" & _ShortRef))
		                                || CONTAINSSTRING(_Expr, UPPER("MIN(" & _ShortRef))
		                                || CONTAINSSTRING(_Expr, UPPER("MAX(" & _ShortRef))
		                                || CONTAINSSTRING(_Expr, UPPER("COUNTA(" & _ShortRef))
		                                || CONTAINSSTRING(_Expr, UPPER("AVERAGEA(" & _ShortRef))
		                                || CONTAINSSTRING(_Expr, UPPER("MAXA(" & _ShortRef))
		                                || CONTAINSSTRING(_Expr, UPPER("MINA(" & _ShortRef))
		                            ))
		                    )
		                ) > 0

		            RETURN _IsAggregated
		        )

		    VAR _ViolationCount = COUNTROWS(_ViolatingColumns)

		    VAR _ColumnsList =
		        CONCATENATEX(
		            _ViolatingColumns,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )

		    VAR _Passed = _ViolationCount = 0

		    VAR _ActualMessage =
		        IF(
		            _ViolationCount > 0,
		            "VISIBLE FACT TABLE COLUMNS USED IN AGGREGATIONS FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _ColumnsList,
		            "ALL FACT TABLE COLUMNS USED IN AGGREGATIONS ARE HIDDEN"
		        )

		    RETURN ROW(
		        "TestName", "[Formatting] Hide fact table columns",
		        "Expected", "Numeric columns used in aggregation measures should be hidden",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "It is a best practice to hide fact table columns that are used for aggregation in measures. Visible numeric columns referenced in SUM, COUNT, AVERAGE, MIN, MAX, DISTINCTCOUNT and other aggregation functions should be hidden to encourage users to use measures instead. Reference: https://blog.crossjoin.co.uk/2024/06/09/get-better-results-from-power-bi-copilot-with-linguistic-modelling/. Severity: High (3)."
		    )
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Runs all formatting best practice checks.
/// This function executes all formatting validation rules and returns combined results.
function 'PQL.Assert.BP.CheckFormatting' =
		() =>
		    UNION(
		        PQL.Assert.BP.ShouldProvideFormatStringForMeasures(),
		        PQL.Assert.BP.ShouldNotSummarizeNumericColumns(),
		        PQL.Assert.BP.ShouldMarkRowLabels(),
		        PQL.Assert.BP.ShouldMarkPrimaryKeys(),
		        PQL.Assert.BP.ShouldHideFactTableColumns()
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10
/// Maintenance Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against maintenance best practices
/// Asserts that hidden measures not referenced by any DAX expressions should be removed.
/// Hidden measures that are not referenced by any DAX expression are unnecessary and should be removed for maintainability.
/// Scope: Measure. CompatibilityLevel >= 1200.
function 'PQL.Assert.BP.ShouldRemoveUnnecessaryMeasures' =
		() =>
		    VAR _Measures = INFO.MEASURES()
		    VAR _Tables = INFO.TABLES()
		    VAR _Columns = INFO.COLUMNS()

		    // Get hidden table IDs
		    VAR _HiddenTableIDs =
		        SELECTCOLUMNS(
		            FILTER(_Tables, [IsHidden]),
		            "@ID", VALUE([ID])
		        )

		    // Get all measure expressions for reference checking
		    VAR _AllMeasureExpressions =
		        SELECTCOLUMNS(
		            _Measures,
		            "@Expr", [Expression]
		        )

		    // Get calculated column expressions for reference checking
		    VAR _CalcColumnExpressions =
		        SELECTCOLUMNS(
		            FILTER(_Columns, [Type] = 2),
		            "@Expr", [Expression]
		        )

		    // Find hidden measures not referenced by any expression
		    VAR _ViolatingMeasures =
		        ADDCOLUMNS(
		            FILTER(
		                _Measures,
		                VAR _MeasureName = [Name]
		                VAR _IsHidden = [IsHidden]
		                VAR _TableID = VALUE([TableID])

		                // Check if table is hidden
		                VAR _TableIsHidden =
		                    COUNTROWS(
		                        FILTER(
		                            _HiddenTableIDs,
		                            [@ID] = _TableID
		                        )
		                    ) > 0

		                // Measure must be hidden (directly or via table)
		                VAR _IsHiddenMeasure = _IsHidden || _TableIsHidden

		                // Check if measure name appears in any other measure expression
		                VAR _SearchPattern = "[" & _MeasureName & "]"
		                VAR _ReferencedInMeasures =
		                    COUNTROWS(
		                        FILTER(
		                            _AllMeasureExpressions,
		                            CONTAINSSTRING([@Expr], _SearchPattern)
		                        )
		                    )

		                // Check if measure name appears in any calculated column expression
		                VAR _ReferencedInColumns =
		                    COUNTROWS(
		                        FILTER(
		                            _CalcColumnExpressions,
		                            CONTAINSSTRING([@Expr], _SearchPattern)
		                        )
		                    )

		                VAR _IsReferenced = (_ReferencedInMeasures + _ReferencedInColumns) > 0

		                RETURN _IsHiddenMeasure && NOT _IsReferenced
		            ),
		            "@TableName",
		                VAR _TableID = VALUE([TableID])
		                RETURN
		                    MAXX(
		                        FILTER(
		                            _Tables,
		                            VALUE([ID]) = _TableID
		                        ),
		                        [Name]
		                    )
		        )

		    VAR _ViolationCount = COUNTROWS(_ViolatingMeasures)

		    VAR _MeasuresList =
		        CONCATENATEX(
		            _ViolatingMeasures,
		            [@TableName] & "[" & [Name] & "]",
		            ", ",
		            [@TableName], ASC,
		            [Name], ASC
		        )

		    VAR _Passed = _ViolationCount = 0

		    VAR _ActualMessage =
		        IF(
		            _ViolationCount > 0,
		            "UNNECESSARY HIDDEN MEASURES FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _MeasuresList,
		            "NO UNNECESSARY HIDDEN MEASURES FOUND"
		        )

		    RETURN ROW(
		        "TestName", "[Maintenance] Remove unnecessary measures",
		        "Expected", "Hidden measures not referenced by any DAX expression should be removed",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Hidden measures that are not referenced by any DAX expression are unnecessary and should be removed for maintainability. Scope: Measure. CompatibilityLevel: 1200. Severity: High (3)."
		    )
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that visible objects should have descriptions.
/// Add descriptions to visible tables, measures, and columns. Descriptions are shown on hover within the Field List in Power BI Desktop.
/// Scope: Table, Measure, DataColumn, CalculatedColumn, CalculatedTable, CalculatedTableColumn, CalculationGroup.
/// CompatibilityLevel >= 1200.
/// Reference: https://www.elegantbi.com/post/datadictionary
function 'PQL.Assert.BP.ShouldHaveObjectDescriptions' =
		() =>
		    VAR _Tables = INFO.TABLES()
		    VAR _Measures = INFO.MEASURES()
		    VAR _Columns = INFO.COLUMNS()

		    // Get hidden table IDs for lookup
		    VAR _HiddenTableIDs =
		        SELECTCOLUMNS(
		            FILTER(_Tables, [IsHidden]),
		            "@ID", VALUE([ID])
		        )

		    // Visible tables without description (exclude system tables)
		    VAR _TablesWithoutDesc =
		        FILTER(
		            _Tables,
		            NOT [IsHidden]
		            && NOT CONTAINSSTRING([Name], "DateTableTemplate")
		            && NOT CONTAINSSTRING([Name], "LocalDateTable")
		            && (ISBLANK([Description]) || [Description] = "")
		        )

		    // Visible measures without description (on visible tables)
		    VAR _MeasuresWithoutDesc =
		        ADDCOLUMNS(
		            FILTER(
		                _Measures,
		                VAR _TableID = VALUE([TableID])
		                VAR _IsHidden = [IsHidden]
		                VAR _TableIsHidden =
		                    COUNTROWS(
		                        FILTER(
		                            _HiddenTableIDs,
		                            [@ID] = _TableID
		                        )
		                    ) > 0
		                RETURN
		                    NOT _IsHidden
		                    && NOT _TableIsHidden
		                    && (ISBLANK([Description]) || [Description] = "")
		            ),
		            "@TableName",
		                VAR _TableID = VALUE([TableID])
		                RETURN
		                    MAXX(
		                        FILTER(
		                            _Tables,
		                            VALUE([ID]) = _TableID
		                        ),
		                        [Name]
		                    )
		        )

		    // Visible columns without description (types 1, 2, 4 on visible tables)
		    VAR _ColumnsWithoutDesc =
		        ADDCOLUMNS(
		            FILTER(
		                _Columns,
		                VAR _TableID = VALUE([TableID])
		                VAR _IsHidden = [IsHidden]
		                VAR _ColumnType = [Type]
		                VAR _TableIsHidden =
		                    COUNTROWS(
		                        FILTER(
		                            _HiddenTableIDs,
		                            [@ID] = _TableID
		                        )
		                    ) > 0
		                VAR _IsInScope = _ColumnType = 1 || _ColumnType = 2 || _ColumnType = 4
		                RETURN
		                    _IsInScope
		                    && NOT _IsHidden
		                    && NOT _TableIsHidden
		                    && (ISBLANK([Description]) || [Description] = "")
		            ),
		            "@TableName",
		                VAR _TableID = VALUE([TableID])
		                RETURN
		                    MAXX(
		                        FILTER(
		                            _Tables,
		                            VALUE([ID]) = _TableID
		                        ),
		                        [Name]
		                    )
		        )

		    VAR _TableCount = COUNTROWS(_TablesWithoutDesc)
		    VAR _MeasureCount = COUNTROWS(_MeasuresWithoutDesc)
		    VAR _ColumnCount = COUNTROWS(_ColumnsWithoutDesc)
		    VAR _ViolationCount = _TableCount + _MeasureCount + _ColumnCount

		    VAR _TablesList =
		        CONCATENATEX(
		            _TablesWithoutDesc,
		            "'" & [Name] & "'",
		            ", ",
		            [Name], ASC
		        )

		    VAR _MeasuresList =
		        CONCATENATEX(
		            _MeasuresWithoutDesc,
		            [@TableName] & "[" & [Name] & "]",
		            ", ",
		            [@TableName], ASC,
		            [Name], ASC
		        )

		    VAR _ColumnsList =
		        CONCATENATEX(
		            _ColumnsWithoutDesc,
		            [@TableName] & "[" & [ExplicitName] & "]",
		            ", ",
		            [@TableName], ASC,
		            [ExplicitName], ASC
		        )

		    VAR _Passed = _ViolationCount = 0

		    VAR _ActualMessage =
		        IF(
		            _ViolationCount > 0,
		            "OBJECTS WITHOUT DESCRIPTIONS (" & FORMAT(_ViolationCount, "0") & ")"
		                & IF(_TableCount > 0, " | Tables (" & FORMAT(_TableCount, "0") & "): " & _TablesList, "")
		                & IF(_MeasureCount > 0, " | Measures (" & FORMAT(_MeasureCount, "0") & "): " & _MeasuresList, "")
		                & IF(_ColumnCount > 0, " | Columns (" & FORMAT(_ColumnCount, "0") & "): " & _ColumnsList, ""),
		            "ALL VISIBLE OBJECTS HAVE DESCRIPTIONS"
		        )

		    RETURN ROW(
		        "TestName", "[Maintenance] Visible objects with no description",
		        "Expected", "All visible tables, measures, and columns should have descriptions",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Add descriptions to visible objects. Descriptions are shown on hover within the Field List in Power BI Desktop. Additionally, you can leverage these descriptions to create an automated data dictionary. Reference: https://www.elegantbi.com/post/datadictionary. Scope: Table, Measure, DataColumn, CalculatedColumn, CalculatedTable, CalculatedTableColumn, CalculationGroup. CompatibilityLevel: 1200. Severity: High (3)."
		    )
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that hidden columns not referenced by any DAX expressions, relationships, hierarchy levels, or Sort By-properties should be removed.
/// Scope: DataColumn, CalculatedColumn, CalculatedTableColumn. CompatibilityLevel >= 1200.
function 'PQL.Assert.BP.ShouldRemoveUnnecessaryColumns' =
		() =>
		    VAR _Columns = INFO.COLUMNS()
		    VAR _Tables = INFO.TABLES()
		    VAR _Dependencies = INFO.CALCDEPENDENCY()
		    VAR _TablePermissions = INFO.TABLEPERMISSIONS()

		    // Get hidden table IDs
		    VAR _HiddenTableIDs =
		        SELECTCOLUMNS(
		            FILTER(_Tables, [IsHidden]),
		            "@ID", VALUE([ID])
		        )

		    // All columns referenced by anything (measures, calc columns, relationships, hierarchies)
		    // REFERENCED_OBJECT_TYPE: COLUMN, CALC_COLUMN for direct refs; ATTRIBUTE_HIERARCHY for hierarchy levels
		    VAR _ReferencedColumns =
		        DISTINCT(
		            SELECTCOLUMNS(
		                FILTER(
		                    _Dependencies,
		                    [REFERENCED_OBJECT_TYPE] = "COLUMN"
		                    || [REFERENCED_OBJECT_TYPE] = "CALC_COLUMN"
		                    || [REFERENCED_OBJECT_TYPE] = "ATTRIBUTE_HIERARCHY"
		                ),
		                "@RefTable", [REFERENCED_TABLE],
		                "@RefColumn", [REFERENCED_OBJECT]
		            )
		        )

		    // Columns used as SortBy target (SortByColumnID references)
		    VAR _SortByColumnIDs =
		        DISTINCT(
		            SELECTCOLUMNS(
		                FILTER(_Columns, NOT ISBLANK([SortByColumnID]) && [SortByColumnID] > 0),
		                "@SortByID", [SortByColumnID]
		            )
		        )

		    // RLS filter expressions (if any roles exist)
		    VAR _RLSExpressions =
		        SELECTCOLUMNS(
		            FILTER(_TablePermissions, NOT ISBLANK([FilterExpression]) && [FilterExpression] <> ""),
		            "@FilterExpr", [FilterExpression]
		        )

		    // Find hidden columns not referenced by anything
		    VAR _ViolatingColumns =
		        ADDCOLUMNS(
		            FILTER(
		                _Columns,
		                VAR _ColumnType = [Type]
		                VAR _IsHidden = [IsHidden]
		                VAR _TableID = VALUE([TableID])
		                VAR _ColumnID = VALUE([ID])
		                VAR _ColumnName = [ExplicitName]

		                // Scope: DataColumn (1), CalculatedColumn (2), CalculatedTableColumn (4)
		                VAR _IsInScope = _ColumnType = 1 || _ColumnType = 2 || _ColumnType = 4

		                // Check if table is hidden
		                VAR _TableIsHidden =
		                    COUNTROWS(
		                        FILTER(
		                            _HiddenTableIDs,
		                            [@ID] = _TableID
		                        )
		                    ) > 0

		                // Column or table must be hidden
		                VAR _IsHiddenColumn = _IsHidden || _TableIsHidden

		                // Get table name for reference matching
		                VAR _TableName =
		                    MAXX(
		                        FILTER(_Tables, VALUE([ID]) = _TableID),
		                        [Name]
		                    )

		                // Check if referenced by any DAX, relationship, or hierarchy
		                VAR _IsReferenced =
		                    COUNTROWS(
		                        FILTER(
		                            _ReferencedColumns,
		                            [@RefTable] = _TableName && [@RefColumn] = _ColumnName
		                        )
		                    ) > 0

		                // Check if used as SortBy target by another column
		                VAR _UsedInSortBy =
		                    COUNTROWS(
		                        FILTER(_SortByColumnIDs, [@SortByID] = _ColumnID)
		                    ) > 0

		                // Check if referenced in RLS filter expressions
		                VAR _SearchPattern1 = _TableName & "[" & _ColumnName & "]"
		                VAR _SearchPattern2 = "'" & _TableName & "'[" & _ColumnName & "]"
		                VAR _UsedInRLS =
		                    COUNTROWS(
		                        FILTER(
		                            _RLSExpressions,
		                            CONTAINSSTRING([@FilterExpr], _SearchPattern1)
		                            || CONTAINSSTRING([@FilterExpr], _SearchPattern2)
		                        )
		                    ) > 0

		                RETURN
		                    _IsInScope
		                    && _IsHiddenColumn
		                    && NOT _IsReferenced
		                    && NOT _UsedInSortBy
		                    && NOT _UsedInRLS
		            ),
		            "@TableName",
		                VAR _TableID = VALUE([TableID])
		                RETURN
		                    MAXX(
		                        FILTER(
		                            _Tables,
		                            VALUE([ID]) = _TableID
		                        ),
		                        [Name]
		                    )
		        )

		    VAR _ViolationCount = COUNTROWS(_ViolatingColumns)

		    VAR _ColumnsList =
		        CONCATENATEX(
		            _ViolatingColumns,
		            [@TableName] & "[" & [ExplicitName] & "]",
		            ", ",
		            [@TableName], ASC,
		            [ExplicitName], ASC
		        )

		    VAR _Passed = _ViolationCount = 0

		    VAR _ActualMessage =
		        IF(
		            _ViolationCount > 0,
		            "UNNECESSARY HIDDEN COLUMNS FOUND (" & FORMAT(_ViolationCount, "0") & "): " & _ColumnsList,
		            "NO UNNECESSARY HIDDEN COLUMNS FOUND"
		        )

		    RETURN ROW(
		        "TestName", "[Maintenance] Remove unnecessary columns",
		        "Expected", "Hidden columns not referenced by any DAX expression, relationship, hierarchy, or SortBy should be removed",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Hidden columns that are not referenced by any DAX expressions, relationships, hierarchy levels, or Sort By-properties should be removed. Scope: DataColumn, CalculatedColumn, CalculatedTableColumn. CompatibilityLevel: 1200. Severity: High (3)."
		    )
    annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Runs all maintenance best practice checks.
/// This function executes all maintenance validation rules and returns combined results.
function 'PQL.Assert.BP.CheckMaintenance' =
		() =>
		    UNION(
		        PQL.Assert.BP.ShouldRemoveUnnecessaryMeasures(),
		        PQL.Assert.BP.ShouldRemoveUnnecessaryColumns(),
		        PQL.Assert.BP.ShouldHaveObjectDescriptions()
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10
/// DAX Best Practice Validation Functions
/// Publisher: PQL (Power Query Lint)
/// These functions validate semantic models against best practices and performance recommendations
/// Asserts that no bi-directional relationships exist on high-cardinality columns.
/// For high-cardinality columns (>1M distinct values), bi-directional relationships can impact performance.
function 'PQL.Assert.BP.ShouldAvoidBiDirectionalOnHighCardinalityColumn' =
		() =>
		    VAR _CardinalityThreshold = 1000000
		    VAR _Relationships = INFO.VIEW.RELATIONSHIPS()
		    VAR _ColumnStats = COLUMNSTATISTICS()
		    VAR _BiDirectionalRels =
		        FILTER(
		            _Relationships,
		            [CrossFilteringBehavior] = "BothDirections"
		        )
		    VAR _HighCardinalityBiDirRels =
		        FILTER(
		            _BiDirectionalRels,
		            VAR _FromTable = [FromTable]
		            VAR _FromColumn = [FromColumn]
		            VAR _ToTable = [ToTable]
		            VAR _ToColumn = [ToColumn]
		            VAR _FromColumnCardinality =
		                MAXX(
		                    FILTER(
		                        _ColumnStats,
		                        [Table Name] = _FromTable && [Column Name] = _FromColumn
		                    ),
		                    [Cardinality]
		                )
		            VAR _ToColumnCardinality =
		                MAXX(
		                    FILTER(
		                        _ColumnStats,
		                        [Table Name] = _ToTable && [Column Name] = _ToColumn
		                    ),
		                    [Cardinality]
		                )
		            RETURN _FromColumnCardinality > _CardinalityThreshold || _ToColumnCardinality > _CardinalityThreshold
		        )
		    VAR _HighCardinalityCount = COUNTROWS(_HighCardinalityBiDirRels)
		    VAR _Passed = _HighCardinalityCount = 0
		    RETURN ROW(
		        "TestName", "[Performance] Avoid bi-directional relationships against high-cardinality columns",
		        "Expected", "No bi-directional relationships on high-cardinality columns (>1M)",
		        "Actual", IF(_HighCardinalityCount > 0, "BI-DIRECTIONAL RELATIONSHIPS ON HIGH-CARDINALITY COLUMNS FOUND (" & FORMAT(_HighCardinalityCount, "0") & ")", "NO HIGH-CARDINALITY BI-DIRECTIONAL RELATIONSHIPS"),
		        "Passed", _Passed,
		        "RuleDescription", "Avoid bi-directional relationships on high-cardinality columns (>1M distinct values) for better performance. Severity: Medium (2)."
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that auto-date tables should be removed.
/// Auto-date tables (DateTableTemplate_* and LocalDateTable_*) consume memory and should be disabled.
function 'PQL.Assert.BP.ShouldRemoveAutoDateTable' =
		() =>
		    VAR _Tables = INFO.VIEW.TABLES()
		    VAR _AutoDateTableCount =
		        COUNTROWS(
		            FILTER(
		                _Tables,
		                LEFT([Name], 18) = "DateTableTemplate_" || LEFT([Name], 15) = "LocalDateTable_"
		            )
		        )
		    VAR _Passed = _AutoDateTableCount = 0
		    RETURN ROW(
		        "TestName", "[Performance] Remove auto-date table",
		        "Expected", "No auto-date tables should exist in the model",
		        "Actual", IF(_AutoDateTableCount > 0, "AUTO-DATE TABLES FOUND (" & FORMAT(_AutoDateTableCount, "0") & ")", "NO AUTO-DATE TABLES"),
		        "Passed", _Passed,
		        "RuleDescription", "Avoid using auto-date tables. Turn off auto-date table in Power BI Desktop settings to save memory. Severity: Medium (2)."
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that no columns use floating point data types.
/// The "Double" floating point data type should be avoided to prevent unpredictable roundoff errors and performance issues.
function 'PQL.Assert.BP.ShouldAvoidFloatingPointDataTypes' =
		() =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _DoubleColumns =
		        FILTER(
		            _Columns,
		            [DataType] = "Number"
		        )
		    VAR _DoubleColumnCount = COUNTROWS(_DoubleColumns)
		    VAR _ColumnsList =
		        CONCATENATEX(
		            _DoubleColumns,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _DoubleColumnCount = 0
		    VAR _ActualMessage =
		        IF(
		            _DoubleColumnCount > 0,
		            "NUMBER DATA TYPE COLUMNS FOUND (" & FORMAT(_DoubleColumnCount, "0") & "): " & _ColumnsList,
		            "NO NUMBER DATA TYPE COLUMNS"
		        )
		    RETURN ROW(
		        "TestName", "[Performance] Do not use floating point data types",
		        "Expected", "No columns should use Number data type",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "Avoid using Number floating point data type, as it can result in unpredictable roundoff errors and decreased performance. Use Int64 or Decimal where appropriate (Decimal limited to 4 digits after decimal). Severity: Medium (2)."
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that IsAvailableInMdx should be set to false on hidden non-attribute columns.
/// Hidden columns that still have IsAvailableInMdx = true cause unnecessary attribute hierarchy builds, consuming memory and slowing processing.
function 'PQL.Assert.BP.ShouldSetIsAvailableInMdxFalseOnNonAttributeColumns' =
		() =>
		    VAR _Columns = INFO.VIEW.COLUMNS()
		    VAR _Tables = INFO.VIEW.TABLES()
		    VAR _ViolatingColumns =
		        FILTER(
		            _Columns,
		            VAR _CurrentTable = [Table]
		            VAR _IsHidden = [IsHidden]
		            VAR _IsAvailableInMDX = [IsAvailableInMDX]
		            VAR _TableIsHidden =
		                COUNTROWS(
		                    FILTER(_Tables, [Name] = _CurrentTable && [IsHidden] = TRUE)
		                ) > 0
		            RETURN
		                _IsAvailableInMDX = TRUE
		                && (_IsHidden = TRUE || _TableIsHidden = TRUE)
		        )
		    VAR _ViolatingColumnCount = COUNTROWS(_ViolatingColumns)
		    VAR _ColumnsList =
		        CONCATENATEX(
		            _ViolatingColumns,
		            [Table] & "[" & [Name] & "]",
		            ", ",
		            [Table], ASC,
		            [Name], ASC
		        )
		    VAR _Passed = _ViolatingColumnCount = 0
		    VAR _ActualMessage =
		        IF(
		            _ViolatingColumnCount > 0,
		            "HIDDEN COLUMNS WITH ISAVAILABLEINMDX=TRUE FOUND (" & FORMAT(_ViolatingColumnCount, "0") & "): " & _ColumnsList,
		            "ALL HIDDEN COLUMNS HAVE ISAVAILABLEINMDX SET TO FALSE"
		        )
		    RETURN ROW(
		        "TestName", "[Performance] Set IsAvailableInMdx to false on non-attribute columns",
		        "Expected", "Hidden columns should have IsAvailableInMdx = false",
		        "Actual", _ActualMessage,
		        "Passed", _Passed,
		        "RuleDescription", "To speed up processing time and conserve memory, attribute hierarchies should not be built for hidden columns. Set IsAvailableInMdx to false for better performance. Severity: Medium (2)."
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Runs all performance best practice checks.
/// This function executes all performance validation rules and returns combined results.
function 'PQL.Assert.BP.CheckPerformance' =
		() =>
		    UNION(
		        PQL.Assert.BP.ShouldAvoidBiDirectionalOnHighCardinalityColumn(),
		        PQL.Assert.BP.ShouldRemoveAutoDateTable(),
		        PQL.Assert.BP.ShouldAvoidFloatingPointDataTypes(),
		        PQL.Assert.BP.ShouldSetIsAvailableInMdxFalseOnNonAttributeColumns()
		    )
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10
/// Col Assertions - PQL.Assert.Col namespace
/// Column-level assertion functions for data quality validation
/// Publisher: PQL (Power Query Lint)
/// Asserts that all values in a column are NULL (DAX BLANK()).
function 'PQL.Assert.Col.ShouldBeNull' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _NonNullCount = DISTINCTCOUNTNOBLANK(columnRef)
			VAR _Passed = _NonNullCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Column is all NULL",
				"Actual", IF(_Passed, "ALL NULL", "HAS NON-NULL VALUES (" & FORMAT(_NonNullCount, "0") & " distinct)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a column contains at least one non-NULL value (not DAX BLANK()).
function 'PQL.Assert.Col.ShouldNotBeNull' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _NonNullCount = DISTINCTCOUNTNOBLANK(columnRef)
			VAR _Passed = _NonNullCount > 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Column has non-NULL values",
				"Actual", IF(_Passed, "HAS VALUES (" & FORMAT(_NonNullCount, "0") & " distinct)", "ALL NULL"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that all values in a column are BLANK (empty string "" or NULL BLANK()). Fails if any non-blank values exist.
function 'PQL.Assert.Col.ShouldBeBlank' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _NonBlankCount = COUNTAX(
				VALUES(columnRef),
				IF(NOT ISBLANK(columnRef) && FORMAT(columnRef, "") <> "", 1, BLANK())
			)
			VAR _TotalCount = COUNTROWS(VALUES(columnRef))
			VAR _Passed = _NonBlankCount = 0 && _TotalCount > 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Column is all BLANK (empty string or NULL)",
				"Actual", IF(_Passed, "ALL BLANK", "HAS NON-BLANK VALUES (" & FORMAT(_NonBlankCount, "0") & " non-blank)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that all values in a column are non-BLANK (not empty string "" and not NULL BLANK()). Fails if any blank values exist.
function 'PQL.Assert.Col.ShouldNotBeBlank' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _BlankCount = COUNTBLANK(columnRef)
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _Passed = _BlankCount = 0 && _TotalCount > 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Column has no BLANK values (all non-empty and non-NULL)",
				"Actual", IF(_Passed, "NO BLANK VALUES", "HAS BLANK VALUES (" & FORMAT(_BlankCount, "0") & " blank)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that all values in a column are NULL or BLANK (BLANK() or empty string ""). Fails if any values with content exist.
function 'PQL.Assert.Col.ShouldBeNullOrBlank' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _NonEmptyCount = COUNTAX(
				VALUES(columnRef),
				IF(NOT ISBLANK(columnRef) && FORMAT(columnRef, "") <> "", 1, BLANK())
			)
			VAR _TotalCount = COUNTROWS(VALUES(columnRef))
			VAR _Passed = _NonEmptyCount = 0 && _TotalCount > 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Column is all NULL or BLANK",
				"Actual", IF(_Passed, "ALL NULL/BLANK", "HAS VALUES (" & FORMAT(_NonEmptyCount, "0") & " non-empty)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that all values in a column are not NULL and not BLANK. Fails if any NULL or empty values exist.
function 'PQL.Assert.Col.ShouldNotBeNullOrBlank' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _BlankCount = COUNTBLANK(columnRef)
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _Passed = _BlankCount = 0 && _TotalCount > 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Column has no NULL or BLANK values (all values have content)",
				"Actual", IF(_Passed, "NO NULL/BLANK VALUES", "HAS NULL/BLANK VALUES (" & FORMAT(_BlankCount, "0") & " empty)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that all values in a column are unique (no duplicates).
function 'PQL.Assert.Col.ShouldBeDistinct' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _DistinctCount = DISTINCTCOUNT(columnRef)
			VAR _TotalCount = COUNTA(columnRef)
			VAR _Passed = _DistinctCount = _TotalCount
			RETURN ROW(
				"TestName", testName,
				"Expected", "All values distinct",
				"Actual", IF(_Passed, "ALL DISTINCT (" & FORMAT(_TotalCount, "0") & " rows)", "DUPLICATES FOUND (" & FORMAT(_DistinctCount, "0") & " distinct of " & FORMAT(_TotalCount, "0") & " rows)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a column exists in a table.
function 'PQL.Assert.Col.ShouldExist' =
		(testName : STRING, tableName : STRING, columnName : STRING) =>
			VAR _Columns = INFO.VIEW.COLUMNS()
			VAR _Found = COUNTROWS(FILTER(_Columns, [Table] = tableName && [Name] = columnName)) > 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Column '" & tableName & "[" & columnName & "]' exists",
				"Actual", IF(_Found, "EXISTS", "NOT FOUND"),
				"Passed", _Found
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Presence / Completeness Thresholds
/// Asserts that the null rate of a column is at most the specified percentage.
function 'PQL.Assert.Col.NullRateShouldBeAtMost' =
		(testName : STRING, columnRef : ANYREF EXPR, maxNullPct : DOUBLE) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _NullCount = COUNTBLANK(columnRef)
			VAR _NullPct = IF(_TotalCount = 0, 0, DIVIDE(_NullCount, _TotalCount) * 100)
			VAR _Passed = _NullPct <= maxNullPct
			RETURN ROW(
				"TestName", testName,
				"Expected", "Null rate <= " & FORMAT(maxNullPct, "0.##") & "%",
				"Actual", FORMAT(_NullPct, "0.##") & "% (" & FORMAT(_NullCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")",
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the blank rate (empty string) of a column is at most the specified percentage.
function 'PQL.Assert.Col.BlankRateShouldBeAtMost' =
		(testName : STRING, columnRef : ANYREF EXPR, maxBlankPct : DOUBLE) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _BlankCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(FORMAT(columnRef, "") = "" && NOT ISBLANK(columnRef), 1, BLANK()))
			VAR _BlankPct = IF(_TotalCount = 0, 0, DIVIDE(_BlankCount, _TotalCount) * 100)
			VAR _Passed = _BlankPct <= maxBlankPct
			RETURN ROW(
				"TestName", testName,
				"Expected", "Blank rate <= " & FORMAT(maxBlankPct, "0.##") & "%",
				"Actual", FORMAT(_BlankPct, "0.##") & "% (" & FORMAT(_BlankCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")",
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the null or blank rate of a column is at most the specified percentage.
function 'PQL.Assert.Col.NullOrBlankRateShouldBeAtMost' =
		(testName : STRING, columnRef : ANYREF EXPR, maxPct : DOUBLE) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _EmptyCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(ISBLANK(columnRef) || FORMAT(columnRef, "") = "", 1, BLANK()))
			VAR _EmptyPct = IF(_TotalCount = 0, 0, DIVIDE(_EmptyCount, _TotalCount) * 100)
			VAR _Passed = _EmptyPct <= maxPct
			RETURN ROW(
				"TestName", testName,
				"Expected", "Null or blank rate <= " & FORMAT(maxPct, "0.##") & "%",
				"Actual", FORMAT(_EmptyPct, "0.##") & "% (" & FORMAT(_EmptyCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")",
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the populated (non-null, non-blank) rate of a column is at least the specified percentage.
function 'PQL.Assert.Col.PopulatedRateShouldBeAtLeast' =
		(testName : STRING, columnRef : ANYREF EXPR, minPct : DOUBLE) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _PopulatedCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(NOT ISBLANK(columnRef) && FORMAT(columnRef, "") <> "", 1, BLANK()))
			VAR _PopulatedPct = IF(_TotalCount = 0, 0, DIVIDE(_PopulatedCount, _TotalCount) * 100)
			VAR _Passed = _PopulatedPct >= minPct
			RETURN ROW(
				"TestName", testName,
				"Expected", "Populated rate >= " & FORMAT(minPct, "0.##") & "%",
				"Actual", FORMAT(_PopulatedPct, "0.##") & "% (" & FORMAT(_PopulatedCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")",
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Uniqueness & Key-Like Behavior
/// Asserts that column values are unique within partitions defined by another column.
function 'PQL.Assert.Col.ShouldBeUniqueWithin' =
		(testName : STRING, columnRef : ANYREF EXPR, partitionByCol : ANYREF EXPR) =>
			VAR _Base = FILTER(ALL(partitionByCol, columnRef), NOT ISBLANK(columnRef))
			VAR _TotalCombinations = COUNTROWS(DISTINCT(_Base))
			VAR _TotalRows = COUNTA(columnRef)
			VAR _Passed = _TotalCombinations = _TotalRows
			RETURN ROW(
				"TestName", testName,
				"Expected", "All values unique within partition",
				"Actual", IF(_Passed, "ALL UNIQUE WITHIN PARTITION (" & FORMAT(_TotalRows, "0") & " rows)", "DUPLICATES WITHIN PARTITION (" & FORMAT(_TotalCombinations, "0") & " unique of " & FORMAT(_TotalRows, "0") & " rows)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the combination of two columns forms a distinct composite key.
function 'PQL.Assert.Col.ComboShouldBeDistinct' =
		(testName : STRING, columnRef1 : ANYREF EXPR, columnRef2 : ANYREF EXPR) =>
			VAR _Base = FILTER(ALL(columnRef1, columnRef2), NOT ISBLANK(columnRef1))
			VAR _DistinctCombos = COUNTROWS(DISTINCT(_Base))
			VAR _TotalRows = COUNTA(columnRef1)
			VAR _Passed = _DistinctCombos = _TotalRows
			RETURN ROW(
				"TestName", testName,
				"Expected", "All combinations distinct (composite key)",
				"Actual", IF(_Passed, "ALL COMBOS DISTINCT (" & FORMAT(_TotalRows, "0") & " rows)", "DUPLICATE COMBOS (" & FORMAT(_DistinctCombos, "0") & " distinct of " & FORMAT(_TotalRows, "0") & " rows)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a column contains no duplicate values. Alias for ShouldBeDistinct.
function 'PQL.Assert.Col.ShouldNotContainDuplicates' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _DistinctCount = DISTINCTCOUNT(columnRef)
			VAR _TotalCount = COUNTA(columnRef)
			VAR _Passed = _DistinctCount = _TotalCount
			RETURN ROW(
				"TestName", testName,
				"Expected", "No duplicate values",
				"Actual", IF(_Passed, "NO DUPLICATES (" & FORMAT(_TotalCount, "0") & " rows)", "DUPLICATES FOUND (" & FORMAT(_DistinctCount, "0") & " distinct of " & FORMAT(_TotalCount, "0") & " rows)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Range & Distribution Checks (Numeric)
/// Asserts that all values in a numeric column fall within the specified inclusive range.
function 'PQL.Assert.Col.ShouldBeInRange' =
		(testName : STRING, columnRef : ANYREF EXPR, minIncl : DOUBLE, maxIncl : DOUBLE) =>
			VAR _MinVal = MINX(ALLNOBLANKROW(columnRef), columnRef)
			VAR _MaxVal = MAXX(ALLNOBLANKROW(columnRef), columnRef)
			VAR _Passed = _MinVal >= minIncl && _MaxVal <= maxIncl
			RETURN ROW(
				"TestName", testName,
				"Expected", FORMAT(minIncl, "") & " <= value <= " & FORMAT(maxIncl, ""),
				"Actual", "Min=" & FORMAT(_MinVal, "") & ", Max=" & FORMAT(_MaxVal, ""),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the minimum value in a column is at least the specified value.
function 'PQL.Assert.Col.MinShouldBeAtLeast' =
		(testName : STRING, columnRef : ANYREF EXPR, minIncl : DOUBLE) =>
			VAR _MinVal = MINX(ALLNOBLANKROW(columnRef), columnRef)
			VAR _Passed = _MinVal >= minIncl
			RETURN ROW(
				"TestName", testName,
				"Expected", "Min >= " & FORMAT(minIncl, ""),
				"Actual", "Min=" & FORMAT(_MinVal, ""),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the maximum value in a column is at most the specified value.
function 'PQL.Assert.Col.MaxShouldBeAtMost' =
		(testName : STRING, columnRef : ANYREF EXPR, maxIncl : DOUBLE) =>
			VAR _MaxVal = MAXX(ALLNOBLANKROW(columnRef), columnRef)
			VAR _Passed = _MaxVal <= maxIncl
			RETURN ROW(
				"TestName", testName,
				"Expected", "Max <= " & FORMAT(maxIncl, ""),
				"Actual", "Max=" & FORMAT(_MaxVal, ""),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the specified percentile of a column falls within the given range.
function 'PQL.Assert.Col.PctileShouldBeInRange' =
		(testName : STRING, columnRef : ANYREF EXPR, pct : DOUBLE, minIncl : DOUBLE, maxIncl : DOUBLE) =>
			VAR _PctileVal = PERCENTILEX.INC(ALLNOBLANKROW(columnRef), columnRef, pct)
			VAR _Passed = _PctileVal >= minIncl && _PctileVal <= maxIncl
			RETURN ROW(
				"TestName", testName,
				"Expected", "P" & FORMAT(pct * 100, "0") & " in [" & FORMAT(minIncl, "") & ", " & FORMAT(maxIncl, "") & "]",
				"Actual", "P" & FORMAT(pct * 100, "0") & "=" & FORMAT(_PctileVal, ""),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the mean of a column falls within the specified range.
function 'PQL.Assert.Col.MeanShouldBeInRange' =
		(testName : STRING, columnRef : ANYREF EXPR, minIncl : DOUBLE, maxIncl : DOUBLE) =>
			VAR _MeanVal = AVERAGEX(ALLNOBLANKROW(columnRef), columnRef)
			VAR _Passed = _MeanVal >= minIncl && _MeanVal <= maxIncl
			RETURN ROW(
				"TestName", testName,
				"Expected", "Mean in [" & FORMAT(minIncl, "") & ", " & FORMAT(maxIncl, "") & "]",
				"Actual", "Mean=" & FORMAT(_MeanVal, ""),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the standard deviation of a column is at most the specified value.
function 'PQL.Assert.Col.StdDevShouldBeAtMost' =
		(testName : STRING, columnRef : ANYREF EXPR, maxStdDev : DOUBLE) =>
			VAR _TblRef = ALLNOBLANKROW(columnRef)
			VAR _Mean = AVERAGEX(_TblRef, columnRef)
			VAR _N = COUNTROWS(_TblRef)
			VAR _SumSqDiff = SUMX(_TblRef, (columnRef - _Mean) ^ 2)
			VAR _StdDev = IF(_N > 1, SQRT(DIVIDE(_SumSqDiff, _N - 1)), 0)
			VAR _Passed = _StdDev <= maxStdDev
			RETURN ROW(
				"TestName", testName,
				"Expected", "StdDev <= " & FORMAT(maxStdDev, ""),
				"Actual", "StdDev=" & FORMAT(_StdDev, "0.##"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the share of zero values in a column is at most the specified percentage.
function 'PQL.Assert.Col.ShareOfZerosAtMost' =
		(testName : STRING, columnRef : ANYREF EXPR, maxPct : DOUBLE) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _ZeroCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(columnRef = 0, 1, BLANK()))
			VAR _ZeroPct = IF(_TotalCount = 0, 0, DIVIDE(_ZeroCount, _TotalCount) * 100)
			VAR _Passed = _ZeroPct <= maxPct
			RETURN ROW(
				"TestName", testName,
				"Expected", "Zero share <= " & FORMAT(maxPct, "0.##") & "%",
				"Actual", FORMAT(_ZeroPct, "0.##") & "% (" & FORMAT(_ZeroCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")",
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the share of even values in a column is at least the specified percentage.
function 'PQL.Assert.Col.ShareOfEvensAtLeast' =
		(testName : STRING, columnRef : ANYREF EXPR, minPct : DOUBLE) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _EvenCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(MOD(columnRef, 2) = 0, 1, BLANK()))
			VAR _EvenPct = IF(_TotalCount = 0, 0, DIVIDE(_EvenCount, _TotalCount) * 100)
			VAR _Passed = _EvenPct >= minPct
			RETURN ROW(
				"TestName", testName,
				"Expected", "Even share >= " & FORMAT(minPct, "0.##") & "%",
				"Actual", FORMAT(_EvenPct, "0.##") & "% (" & FORMAT(_EvenCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")",
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the share of odd values in a column is at least the specified percentage.
function 'PQL.Assert.Col.ShareOfOddsAtLeast' =
		(testName : STRING, columnRef : ANYREF EXPR, minPct : DOUBLE) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _OddCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(MOD(columnRef, 2) <> 0, 1, BLANK()))
			VAR _OddPct = IF(_TotalCount = 0, 0, DIVIDE(_OddCount, _TotalCount) * 100)
			VAR _Passed = _OddPct >= minPct
			RETURN ROW(
				"TestName", testName,
				"Expected", "Odd share >= " & FORMAT(minPct, "0.##") & "%",
				"Actual", FORMAT(_OddPct, "0.##") & "% (" & FORMAT(_OddCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")",
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Sign & Monotonicity
/// Asserts that all values in a column are non-negative (>= 0).
function 'PQL.Assert.Col.ShouldBeNonNegative' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _MinVal = MINX(ALLNOBLANKROW(columnRef), columnRef)
			VAR _NegativeCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(columnRef < 0, 1, BLANK()))
			VAR _Passed = _NegativeCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "All values >= 0",
				"Actual", IF(_Passed, "ALL NON-NEGATIVE (Min=" & FORMAT(_MinVal, "") & ")", "NEGATIVE VALUES FOUND (" & FORMAT(_NegativeCount, "0") & ", Min=" & FORMAT(_MinVal, "") & ")"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that all values in a column are strictly positive (> 0).
function 'PQL.Assert.Col.ShouldBePositive' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _MinVal = MINX(ALLNOBLANKROW(columnRef), columnRef)
			VAR _NonPositiveCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(columnRef <= 0, 1, BLANK()))
			VAR _Passed = _NonPositiveCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "All values > 0",
				"Actual", IF(_Passed, "ALL POSITIVE (Min=" & FORMAT(_MinVal, "") & ")", "NON-POSITIVE VALUES FOUND (" & FORMAT(_NonPositiveCount, "0") & ", Min=" & FORMAT(_MinVal, "") & ")"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that no values in a column are zero.
function 'PQL.Assert.Col.ShouldBeNonZero' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _ZeroCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(columnRef = 0, 1, BLANK()))
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _Passed = _ZeroCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "No zero values",
				"Actual", IF(_Passed, "NO ZEROS (" & FORMAT(_TotalCount, "0") & " rows)", "ZEROS FOUND (" & FORMAT(_ZeroCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that values in a column are monotonically strictly increasing when ordered by another column.
function 'PQL.Assert.Col.ShouldBeMonotonicIncreasing' =
		(testName : STRING, columnRef : ANYREF EXPR, orderedByCol : ANYREF EXPR) =>
			VAR _Tbl = ADDCOLUMNS(
				ALLNOBLANKROW(columnRef),
				"@OrderVal", orderedByCol
			)
			VAR _Sorted = ADDCOLUMNS(
				_Tbl,
				"@RowNum", RANKX(_Tbl, [@OrderVal], , ASC, DENSE)
			)
			VAR _WithPrev = ADDCOLUMNS(
				_Sorted,
				"@PrevVal", VAR _CurRank = [@RowNum] RETURN MAXX(FILTER(_Sorted, [@RowNum] = _CurRank - 1), columnRef)
			)
			VAR _Violations = COUNTAX(_WithPrev, IF(NOT ISBLANK([@PrevVal]) && columnRef <= [@PrevVal], 1, BLANK()))
			VAR _Passed = _Violations = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Values monotonically increasing",
				"Actual", IF(_Passed, "MONOTONIC INCREASING", "NOT MONOTONIC (" & FORMAT(_Violations, "0") & " violations)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that values in a column are monotonically non-decreasing when ordered by another column.
function 'PQL.Assert.Col.ShouldBeMonotonicNonDecreasing' =
		(testName : STRING, columnRef : ANYREF EXPR, orderedByCol : ANYREF EXPR) =>
			VAR _Tbl = ADDCOLUMNS(
				ALLNOBLANKROW(columnRef),
				"@OrderVal", orderedByCol
			)
			VAR _Sorted = ADDCOLUMNS(
				_Tbl,
				"@RowNum", RANKX(_Tbl, [@OrderVal], , ASC, DENSE)
			)
			VAR _WithPrev = ADDCOLUMNS(
				_Sorted,
				"@PrevVal", VAR _CurRank = [@RowNum] RETURN MAXX(FILTER(_Sorted, [@RowNum] = _CurRank - 1), columnRef)
			)
			VAR _Violations = COUNTAX(_WithPrev, IF(NOT ISBLANK([@PrevVal]) && columnRef < [@PrevVal], 1, BLANK()))
			VAR _Passed = _Violations = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Values monotonically non-decreasing",
				"Actual", IF(_Passed, "MONOTONIC NON-DECREASING", "NOT MONOTONIC (" & FORMAT(_Violations, "0") & " violations)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that values in a column are monotonically strictly decreasing when ordered by another column.
function 'PQL.Assert.Col.ShouldBeMonotonicDecreasing' =
		(testName : STRING, columnRef : ANYREF EXPR, orderedByCol : ANYREF EXPR) =>
			VAR _Tbl = ADDCOLUMNS(
				ALLNOBLANKROW(columnRef),
				"@OrderVal", orderedByCol
			)
			VAR _Sorted = ADDCOLUMNS(
				_Tbl,
				"@RowNum", RANKX(_Tbl, [@OrderVal], , ASC, DENSE)
			)
			VAR _WithPrev = ADDCOLUMNS(
				_Sorted,
				"@PrevVal", VAR _CurRank = [@RowNum] RETURN MAXX(FILTER(_Sorted, [@RowNum] = _CurRank - 1), columnRef)
			)
			VAR _Violations = COUNTAX(_WithPrev, IF(NOT ISBLANK([@PrevVal]) && columnRef >= [@PrevVal], 1, BLANK()))
			VAR _Passed = _Violations = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Values monotonically decreasing",
				"Actual", IF(_Passed, "MONOTONIC DECREASING", "NOT MONOTONIC (" & FORMAT(_Violations, "0") & " violations)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Categorical / Membership / Format
/// Asserts that all values in a column are in the specified allowed set (table).
function 'PQL.Assert.Col.ValuesShouldBeInSet' =
		(testName : STRING, columnRef : ANYREF EXPR, allowedValues : TABLE) =>
			VAR _DistinctVals = DISTINCT(columnRef)
			VAR _InvalidCount = COUNTROWS(EXCEPT(_DistinctVals, allowedValues))
			VAR _Passed = _InvalidCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "All values in allowed set",
				"Actual", IF(_Passed, "ALL VALUES IN SET", "VALUES OUTSIDE SET (" & FORMAT(_InvalidCount, "0") & " invalid)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that no values in a column are in the specified banned set (table).
function 'PQL.Assert.Col.ValuesShouldNotBeInSet' =
		(testName : STRING, columnRef : ANYREF EXPR, bannedValues : TABLE) =>
			VAR _DistinctVals = DISTINCT(columnRef)
			VAR _BannedFound = COUNTROWS(INTERSECT(_DistinctVals, bannedValues))
			VAR _Passed = _BannedFound = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "No values in banned set",
				"Actual", IF(_Passed, "NO BANNED VALUES FOUND", "BANNED VALUES FOUND (" & FORMAT(_BannedFound, "0") & ")"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the distinct count of values in a column is at most the specified number.
function 'PQL.Assert.Col.DistinctCountShouldBeAtMost' =
		(testName : STRING, columnRef : ANYREF EXPR, maxDistinct : INT64) =>
			VAR _DistinctCount = DISTINCTCOUNT(columnRef)
			VAR _Passed = _DistinctCount <= maxDistinct
			RETURN ROW(
				"TestName", testName,
				"Expected", "Distinct count <= " & FORMAT(maxDistinct, "0"),
				"Actual", "Distinct count = " & FORMAT(_DistinctCount, "0"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that the distinct count of values in a column is at least the specified number.
function 'PQL.Assert.Col.DistinctCountShouldBeAtLeast' =
		(testName : STRING, columnRef : ANYREF EXPR, minDistinct : INT64) =>
			VAR _DistinctCount = DISTINCTCOUNT(columnRef)
			VAR _Passed = _DistinctCount >= minDistinct
			RETURN ROW(
				"TestName", testName,
				"Expected", "Distinct count >= " & FORMAT(minDistinct, "0"),
				"Actual", "Distinct count = " & FORMAT(_DistinctCount, "0"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that no text values in a column have leading or trailing spaces.
function 'PQL.Assert.Col.TextShouldHaveNoLeadingOrTrailingSpaces' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _UntrimmedCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(NOT ISBLANK(columnRef) && FORMAT(columnRef, "") <> TRIM(FORMAT(columnRef, "")), 1, BLANK()))
			VAR _Passed = _UntrimmedCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "No leading or trailing spaces",
				"Actual", IF(_Passed, "ALL TRIMMED (" & FORMAT(_TotalCount, "0") & " rows)", "UNTRIMMED VALUES (" & FORMAT(_UntrimmedCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that all text values in a column are trimmed. Alias for TextShouldHaveNoLeadingOrTrailingSpaces.
function 'PQL.Assert.Col.TextShouldBeTrimmed' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _UntrimmedCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(NOT ISBLANK(columnRef) && FORMAT(columnRef, "") <> TRIM(FORMAT(columnRef, "")), 1, BLANK()))
			VAR _Passed = _UntrimmedCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "All values trimmed",
				"Actual", IF(_Passed, "ALL TRIMMED (" & FORMAT(_TotalCount, "0") & " rows)", "UNTRIMMED VALUES (" & FORMAT(_UntrimmedCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that all text values in a column are uppercase.
function 'PQL.Assert.Col.TextCaseShouldBeUpper' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _NonUpperCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(NOT ISBLANK(columnRef) && NOT EXACT(FORMAT(columnRef, ""), UPPER(FORMAT(columnRef, ""))), 1, BLANK()))
			VAR _Passed = _NonUpperCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "All values uppercase",
				"Actual", IF(_Passed, "ALL UPPERCASE (" & FORMAT(_TotalCount, "0") & " rows)", "NON-UPPERCASE VALUES (" & FORMAT(_NonUpperCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that all text values in a column are lowercase.
function 'PQL.Assert.Col.TextCaseShouldBeLower' =
		(testName : STRING, columnRef : ANYREF EXPR) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _NonLowerCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(NOT ISBLANK(columnRef) && NOT EXACT(FORMAT(columnRef, ""), LOWER(FORMAT(columnRef, ""))), 1, BLANK()))
			VAR _Passed = _NonLowerCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "All values lowercase",
				"Actual", IF(_Passed, "ALL LOWERCASE (" & FORMAT(_TotalCount, "0") & " rows)", "NON-LOWERCASE VALUES (" & FORMAT(_NonLowerCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that text lengths in a column fall within the specified range.
function 'PQL.Assert.Col.TextLengthShouldBeInRange' =
		(testName : STRING, columnRef : ANYREF EXPR, minLen : INT64, maxLen : INT64) =>
			VAR _TotalCount = COUNTROWS(ALLNOBLANKROW(columnRef))
			VAR _OutOfRangeCount = COUNTAX(ALLNOBLANKROW(columnRef), IF(NOT ISBLANK(columnRef) && (LEN(FORMAT(columnRef, "")) < minLen || LEN(FORMAT(columnRef, "")) > maxLen), 1, BLANK()))
			VAR _Passed = _OutOfRangeCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Text length in [" & FORMAT(minLen, "0") & ", " & FORMAT(maxLen, "0") & "]",
				"Actual", IF(_Passed, "ALL IN RANGE (" & FORMAT(_TotalCount, "0") & " rows)", "OUT OF RANGE (" & FORMAT(_OutOfRangeCount, "0") & " of " & FORMAT(_TotalCount, "0") & ")"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10
/// Table Assertions - PQL.Assert.Tbl namespace
/// Table-level assertion functions for schema and structure validation
/// Publisher: PQL (Power Query Lint)
/// Asserts that a table has at least one row.
function 'PQL.Assert.Tbl.ShouldHaveRows' =
		(testName : STRING, tableRef : TABLE EXPR) =>
			VAR _RowCount = COUNTROWS(tableRef)
			VAR _Passed = _RowCount > 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Table has rows",
				"Actual", IF(_Passed, "HAS ROWS (" & FORMAT(_RowCount, "0") & ")", "EMPTY (0 rows)"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a table has exactly the expected number of rows.
function 'PQL.Assert.Tbl.ShouldHaveRowCount' =
		(testName : STRING, tableRef : TABLE EXPR, expectedRowCount : INT64) =>
			VAR _RowCount = COUNTROWS(tableRef)
			VAR _Passed = _RowCount = expectedRowCount
			RETURN ROW(
				"TestName", testName,
				"Expected", FORMAT(expectedRowCount, "0") & " rows",
				"Actual", FORMAT(_RowCount, "0") & " rows",
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a table has more rows than the specified threshold.
function 'PQL.Assert.Tbl.ShouldHaveMoreRowsThan' =
		(testName : STRING, threshold : INT64, tableToCheck : TABLE) =>
			VAR _RowCount = COUNTROWS(tableToCheck)
			VAR _Passed = _RowCount > threshold
			RETURN ROW(
				"TestName", testName,
				"Expected", "> " & FORMAT(threshold, "0"),
				"Actual", FORMAT(_RowCount, "0"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a table exists in the model.
function 'PQL.Assert.Tbl.ShouldExist' =
		(testName : STRING, tableName : STRING) =>
			VAR _Tables = INFO.VIEW.TABLES()
			VAR _Found = COUNTROWS(FILTER(_Tables, [Name] = tableName)) > 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Table '" & tableName & "' exists",
				"Actual", IF(_Found, "EXISTS", "NOT FOUND"),
				"Passed", _Found
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Schema & Column Shape
/// Asserts that a table has all the specified columns (comma-separated list).
function 'PQL.Assert.Tbl.ShouldHaveColumns' =
		(testName : STRING, tableRef : STRING, columnNamesList : STRING) =>
			VAR _Columns = INFO.VIEW.COLUMNS()
			VAR _TableColumns = FILTER(_Columns, [Table] = tableRef)
			VAR _ExpectedCount = LEN(columnNamesList) - LEN(SUBSTITUTE(columnNamesList, ",", "")) + 1
			VAR _ColumnNamesUpper = UPPER(columnNamesList)
			VAR _MatchedColumns = FILTER(
				_TableColumns,
				CONTAINSSTRING("," & _ColumnNamesUpper & ",", "," & TRIM(UPPER([Name])) & ",")
			)
			VAR _MatchedCount = COUNTROWS(_MatchedColumns)
			VAR _MissingCount = _ExpectedCount - _MatchedCount
			VAR _ActualColumnNames = CONCATENATEX(_TableColumns, [Name], ", ", [Name], ASC)
			VAR _Passed = _MissingCount <= 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "Table '" & tableRef & "' has columns: " & columnNamesList,
				"Actual", IF(_Passed, "ALL COLUMNS FOUND", "MISSING " & FORMAT(_MissingCount, "0") & " COLUMN(S). Available: " & _ActualColumnNames),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a table does not have extra columns beyond the allowed list (comma-separated).
function 'PQL.Assert.Tbl.ShouldNotHaveExtraColumns' =
		(testName : STRING, tableRef : STRING, allowedColumnNamesList : STRING) =>
			VAR _Columns = INFO.VIEW.COLUMNS()
			VAR _TableColumns = FILTER(_Columns, [Table] = tableRef && [Type] <> "RowNumber")
			VAR _TableColumnCount = COUNTROWS(_TableColumns)
			VAR _AllowedUpper = UPPER(allowedColumnNamesList)
			VAR _ExtraColumns = FILTER(
				_TableColumns,
				NOT CONTAINSSTRING("," & _AllowedUpper & ",", "," & TRIM(UPPER([Name])) & ",")
			)
			VAR _ExtraCount = COUNTROWS(_ExtraColumns)
			VAR _ExtraList = CONCATENATEX(_ExtraColumns, [Name], ", ", [Name], ASC)
			VAR _Passed = _ExtraCount = 0
			RETURN ROW(
				"TestName", testName,
				"Expected", "No extra columns beyond: " & allowedColumnNamesList,
				"Actual", IF(_Passed, "NO EXTRA COLUMNS (" & FORMAT(_TableColumnCount, "0") & " columns)", "EXTRA COLUMNS FOUND (" & FORMAT(_ExtraCount, "0") & "): " & _ExtraList),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10`n/// Asserts that a column in a table has the expected data type.
function 'PQL.Assert.Tbl.ColumnDataTypeShouldBe' =
		(testName : STRING, tableRef : STRING, columnName : STRING, expectedType : STRING) =>
			VAR _Columns = INFO.VIEW.COLUMNS()
			VAR _MatchingColumn = FILTER(_Columns, [Table] = tableRef && [Name] = columnName)
			VAR _Found = COUNTROWS(_MatchingColumn) > 0
			VAR _ActualType = IF(_Found, MAXX(_MatchingColumn, [DataType]), "COLUMN NOT FOUND")
			VAR _Passed = _Found && UPPER(_ActualType) = UPPER(expectedType)
			RETURN ROW(
				"TestName", testName,
				"Expected", "Column '" & tableRef & "[" & columnName & "]' data type = " & expectedType,
				"Actual", IF(_Found, "DataType = " & _ActualType, "COLUMN NOT FOUND"),
				"Passed", _Passed
			)
	annotation DAXLIB_PackageId = PQL.Assert
	annotation DAXLIB_PackageVersion = 0.1.10